Logging:
  workflow_level: enumerate(('INFO', 'DEBUG')) # How detailed the logs regarding workflow should be (possible values: INFO and DEBUG; default value: INFO)
  utils_level: enumerate(('INFO', 'DEBUG')) #  How detailed the logs regarding nipype utils, like file operations (for example overwriting warning) or the resource profiler, should be (possible values: INFO and DEBUG; default value: INFO)
  interface_level: enumerate(('INFO', 'DEBUG')) # How detailed the logs regarding interface execution should be (possible values: INFO and DEBUG; default value: INFO)
  filemanip_level: enumerate(('INFO', 'DEBUG')) # (deprecated as of 1.0): How detailed the logs regarding file operations (for example overwriting warning) should be (possible values: INFO and DEBUG)
  log_to_file: False # Indicates whether logging should also send the output to a file (possible values: true and false; default value: false)
  log_directory: 'path' # Where to store logs. (string, default value: home directory)
  log_size: 254000 # Size of a single log file. (integer, default value: 254000)
  log_rotate: 4 #How many rotations should the log file make. (integer, default value: 4)
Execution:
  plugin: enumerate(('Linear', 'MultiProc', 'SGE', 'IPython')) # This defines which execution plugin to use. (possible values: Linear, MultiProc, SGE, IPython; default value: Linear)
  stop_on_first_crash: False # Should the workflow stop upon the first node crashing or try to execute as many nodes as possible? (possible values: true and false; default value: false)
  stop_on_first_rerun: False # Should the workflow stop upon the first node trying to recompute (by that we mean rerunning a node that has been run before - this can happen due changed inputs and/or hash_method since the last run). (possible values: true and false; default value: false)
  hash_method: enumerate(('timestamp', 'content')) # Should the input files be checked for changes using their content (slow, but 100% accurate) or just their size and modification date (fast, but potentially prone to errors)? (possible values: content and timestamp; default value: timestamp)
  keep_inputs: False # Ensures that all inputs that are created in the nodes working directory are kept after node execution (possible values: true and false; default value: false)
  single_thread_matlab: enumerate(('true', 'false')) # Should all of the Matlab interfaces (including SPM) use only one thread? This is useful if you are parallelizing your workflow using MultiProc or IPython on a single multicore machine. (possible values: true and false; default value: true)
  display_variable: '' # Override the $DISPLAY environment variable for interfaces that require an X server. This option is useful if there is a running X server, but $DISPLAY was not defined in nipype's environment. For example, if an X server is listening on the default port of 6000, set display_variable = :0 to enable nipype interfaces to use it. It may also point to displays provided by VNC, xnest or Xvfb. If neither display_variable nor the $DISPLAY environment variable is set, nipype will try to configure a new virtual server using Xvfb. (possible values: any X server address; default value: not set)
  remove_unnecessary_outputs: True #  This will remove any interface outputs not needed by the workflow. If the required outputs from a node changes, rerunning the workflow will rerun the node. Outputs of leaf nodes (nodes whose outputs are not connected to any other nodes) will never be deleted independent of this parameter. (possible values: true and false; default value: true)
  try_hard_link_datasink: True # When the DataSink is used to produce an organized output file outside of nipypes internal cache structure, a file system hard link will be attempted first. A hard link allows multiple file paths to point to the same physical storage location on disk if the conditions allow. By referring to the same physical file on disk (instead of copying files byte-by-byte) we can avoid unnecessary data duplication. If hard links are not supported for the source or destination paths specified, then a standard byte-by-byte copy is used. (possible values: true and false; default value: true)
  use_relative_paths: False # Should the paths stored in results (and used to look for inputs) be relative or absolute. Relative paths allow moving the whole working directory around but may cause problems with symlinks. (possible values: true and false; default value: false)
  local_hash_check: True # Perform the hash check on the job submission machine. This option minimizes the number of jobs submitted to a cluster engine or a multiprocessing pool to only those that need to be rerun. (possible values: true and false; default value: true)
  job_finished_timeout: False # When batch jobs are submitted through, SGE/PBS/Condor they could be killed externally. Nipype checks to see if a results file exists to determine if the node has completed. This timeout determines for how long this check is done after a job finish is detected. (float in seconds; default value: 5)
  remove_node_directories: True # (EXPERIMENTAL): Removes directories whose outputs have already been used up. Doesn't work with IdentiInterface or any node that patches data through (without copying) (possible values: true and false; default value: false)
  stop_on_unknown_version: True # If this is set to True, an underlying interface will raise an error, when no version information is available. Please notify developers or submit a patch.
  parameterize_dirs: True # If this is set to True, the node's output directory will contain full parameterization of any iterable, otherwise parameterizations over 32 characters will be replaced by their hash. (possible values: true and false; default value: true)
  poll_sleep_duration: 2 # This controls how long the job submission loop will sleep between submitting all pending jobs and checking for job completion. To be nice to cluster schedulers the default is set to 2 seconds.
  xvfb_max_wait: 1 # Maximum time (in seconds) to wait for Xvfb to start, if the _redirect_x parameter of an Interface is True.
  crashfile_format: enumerate(('pklz', 'txt')) # This option controls the file type of any crashfile generated. Pklz crashfiles allow interactive debugging and rerunning of nodes, while text crashfiles allow portability across machines and shorter load time. (possible values: pklz and txt; default value: pklz